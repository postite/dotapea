package parse5;

@:jsRequire("parse5", "ErrorCodes") @:enum extern abstract ErrorCodes(String) from String to String {
	var controlCharacterInInputStream;
	var noncharacterInInputStream;
	var surrogateInInputStream;
	var nonVoidHtmlElementStartTagWithTrailingSolidus;
	var endTagWithAttributes;
	var endTagWithTrailingSolidus;
	var unexpectedSolidusInTag;
	var unexpectedNullCharacter;
	var unexpectedQuestionMarkInsteadOfTagName;
	var invalidFirstCharacterOfTagName;
	var unexpectedEqualsSignBeforeAttributeName;
	var missingEndTagName;
	var unexpectedCharacterInAttributeName;
	var unknownNamedCharacterReference;
	var missingSemicolonAfterCharacterReference;
	var unexpectedCharacterAfterDoctypeSystemIdentifier;
	var unexpectedCharacterInUnquotedAttributeValue;
	var eofBeforeTagName;
	var eofInTag;
	var missingAttributeValue;
	var missingWhitespaceBetweenAttributes;
	var missingWhitespaceAfterDoctypePublicKeyword;
	var missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers;
	var missingWhitespaceAfterDoctypeSystemKeyword;
	var missingQuoteBeforeDoctypePublicIdentifier;
	var missingQuoteBeforeDoctypeSystemIdentifier;
	var missingDoctypePublicIdentifier;
	var missingDoctypeSystemIdentifier;
	var abruptDoctypePublicIdentifier;
	var abruptDoctypeSystemIdentifier;
	var cdataInHtmlContent;
	var incorrectlyOpenedComment;
	var eofInScriptHtmlCommentLikeText;
	var eofInDoctype;
	var nestedComment;
	var abruptClosingOfEmptyComment;
	var eofInComment;
	var incorrectlyClosedComment;
	var eofInCdata;
	var absenceOfDigitsInNumericCharacterReference;
	var nullCharacterReference;
	var surrogateCharacterReference;
	var characterReferenceOutsideUnicodeRange;
	var controlCharacterReference;
	var noncharacterCharacterReference;
	var missingWhitespaceBeforeDoctypeName;
	var missingDoctypeName;
	var invalidCharacterSequenceAfterDoctypeName;
	var duplicateAttribute;
	var nonConformingDoctype;
	var missingDoctype;
	var misplacedDoctype;
	var endTagWithoutMatchingOpenElement;
	var closingOfElementWithOpenChildElements;
	var disallowedContentInNoscriptInHead;
	var openElementsLeftAfterEof;
	var abandonedHeadElementChild;
	var misplacedStartTagForHeadElement;
	var nestedNoscriptInHead;
	var eofInElementThatCanContainOnlyText;
}